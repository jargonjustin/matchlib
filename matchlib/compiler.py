import os, imp, tempfile, time, token, tokenize

import matchlib
from matchlib.ast import *
from matchlib import pattern_parser as parser
from matchlib import codegen as g
from matchlib import debug

### Compiler Frontend and Public API ###

def main (argv=None):
    "Runs the compiler frontend and exits"
    
    from optparse import OptionParser
    import os, sys, traceback
    
    if argv is None:
        argv = sys.argv
    
    def fail (message):
        print >>sys.stderr, '%s: %s' % (os.path.basename (sys.argv[0]), message)
        return 1
    
    def fail_exception (exctype, exception):
        traceback.print_exception (exctype, exception, tb=None, file=sys.stderr)
        return 1
    
    optparser = OptionParser (usage="%prog [options] file...")
    optparser.add_option ('-o', dest='outFile', help='output filename', metavar="<file>")
    (options, args) = optparser.parse_args ()
    
    if not args:
        return fail ('no input files')
    elif options.outFile and len (args) != 1:
        return fail ('output specified for multiple inputs')
    
    try:
        if options.outFile is None:
            for infile in args:
                (path, ext) = os.path.splitext (infile)
                if ext != '.mpy':
                    return fail ('invalid file type (expected .mpy, got %s)' % ext)
                compile_file (infile, path + '.py')
        else:
            compile_file (args[0], options.outFile)
    except IOError, err:
        return fail ('%s: %s' % (err.strerror, err.filename))
    except IndentationError, err:
        return fail_exception (IndentationError, err)
    except SyntaxError, err:
        return fail_exception (SyntaxError, err)
    except parser.ParseError, err:
        parser.print_failure (err)
        return 1
    else:
        return 0

def compile_as_module (modulename, filename):
    "Compiles and returns the filename as a module"
    inp, out = None, None
    try:
        inp = open (filename, 'U')
        
        # Create and open a temporary file for writting.  We need to do this
        # because imp.load_module requires a file object (a StringIO won't)
        # pass muster
        (fd, outname) = tempfile.mkstemp (suffix='.py')
        out = os.fdopen (fd, 'w+')
        
        # Compile from one file to the other
        compile_piped (inp, out, filename)
        
        # Seek to the begining of the compiled source
        out.seek (0)
        
        # TODO: the compiled output goes in whatever is passed as the filename
        # parameter + 'c', should we leave it as the .mpy file or switch the
        # extension to '.py' to generate a normally loadable '.pyc'?
        return imp.load_source (modulename, filename, out)
    finally:
        # Close the files and remove the temporary file
        if inp: inp.close ()
        if out:
            out.close ()
            os.remove (outname)

def compile_file (input_filename, output_filename):
    "Compiles the input file and writes the output to the output file"
    # Opens the files and passes them off to compile_piped, cleaning up
    # afterwards if necessary
    inp, out = None, None
    try:
        inp = open (input_filename, 'U')
        out = open (output_filename, 'w')
        compile_piped (inp, out, input_filename)
    finally:
        if inp: inp.close ()
        if out: out.close ()

def compile_piped (inp, out, filename=None):
    
    """Reads the source from one file-like object and writes the compiled output to another
    
    The optional filename argument is used for debugging annotations.
    
    May throw a matchlib.pattern_parser.ParseError, IndentationError, or SyntaxError if
    there is a syntactic error in the input.
    """
    
    # Parse and compile the input
    compiled_lines = compile_lines (parser.parse_handle (inp, filename))
    # Annotate and serialize the compiled output
    compiled_source = ''.join (parser.unlines (debug.annotate (compiled_lines, filename)))
    # Raise an exception if there is a syntactic error
    debug.check_syntax (compiled_source)
    # Write out the debugging header
    out.write ("# compiled by matchlib version %s on %s\n" % (matchlib.__version__, time.asctime ()))
    if filename is not None:
        out.write ("# original source file: %s\n" % filename)
    out.write ("\n")
    out.write ("# DO NOT MODIFY THIS FILE\n")
    out.write ("# This file is automatically generated, any modifications will likely be overwritten\n\n")
    # Write out the source
    out.write (compiled_source)

### Compiler Internals ###
# Here there be dragons

def compile_lines (lines):
    
    """Transforms lines of the form generated by pattern_parser.parse and
       pattern_parser.lines into lines without match statements, replacing
       them with equivilent python code."""
    
    lines = iter (lines)
    while True:
        line = lines.next ()
        if line[0] is parser.MATCH:
            compiler = MatchCompiler (line[1])
            while True:
                line = lines.next ()
                if line[0] is parser.CASE:
                    (patterns, predicate) = line[1]
                    body = list (compile_lines (parser.extract_block (lines)))
                    compiler.add_case (patterns, predicate, body)
                elif line[0] is parser.END:
                    break
                else:
                    parser.fail ('expected case statement', line[1][0])
            (funcLines, actionLines) = compiler.compile ()
            for line in funcLines: yield line
            for line in actionLines: yield line
        else:
            yield line

class MatchCompiler (object):
    
    def __init__ (self, match_expr):
        self.match_expr = match_expr
        self.cases = list ()
    
    def add_case (self, patterns, predicate, body):
        self.cases.append ((patterns, predicate, body))
    
    def compile (self, funcTarget=None, actionTarget=None):
        (funcId, params, variables, funcCode) = self.__compile_function (funcTarget)
        actionCode = self.__compile_actions (funcId, params, variables, actionTarget)
        return (funcCode, actionCode)
    
    def __extractors (self):
        extractors, stack = set (), list ()
        for (patterns, predicate, body) in self.cases:
            stack.extend (patterns)
        while stack:
            pattern = stack.pop ()
            if isinstance (pattern, PExtractor):
                extractors.add (pattern.extractor)
            elif isinstance (pattern, PTuple) or isinstance (pattern, PList):
               stack.extend (pattern.patterns)
            elif isinstance (pattern, PDict):
                stack.extend ([
                    pairing[1] for pairing in pattern.pairings
                    if not isinstance (pairing, PSplat)
                ])
            elif isinstance (pattern, PBind):
                stack.append (pattern.pattern)
        return extractors
    
    def __compile_function (self, target=None):
        funcId = g.Id (g.UniqueName ())
        bindingMap = dict ()
        params = map (g.Id, self.__extractors ())
        gen = g.CodeGenerator (target)
        
        binding = g.Id (g.UniqueName ())
        patternCompiler = PatternCompiler (binding, gen.target)
        
        gen.Def (funcId, binding, *params)
        
        for case_id, (patterns, predicate, body) in enumerate (self.cases):
            for pat_id, pattern in enumerate (patterns):
                indent = patternCompiler.compile (pattern, predicate)
                if len (patternCompiler.bindings) > 0:
                    variables, bindings = zip (*patternCompiler.bindings.items ())
                else:
                    variables, bindings = list (), list ()
                bindingMap[pattern] = variables
                gen.Return (g.Tuple (g.lift (case_id), g.lift (pat_id), *bindings))
                gen.dedent (indent)
        gen.dedent ()
        
        return (funcId, params, bindingMap, gen.target)
    
    def __compile_actions (self, funcId, args, variables, target=None):
        gen = g.CodeGenerator (target)
        binding = g.Id (g.UniqueName ())
        
        gen.Assign (binding, g.Call (funcId, self.match_expr, *args))
        
        gen.If (g.Is (binding, g.lift (None)))
        gen.Raise (g.Id ('ValueError'), g.lift ("pattern match failed"))
        gen.dedent ()
        
        for case_id, (patterns, predicate, body) in enumerate (self.cases):
            gen.ElIf (g.Is (g.Index (binding, g.lift (0)), g.lift (case_id)))
            started = False
            for pat_id, pattern in enumerate (patterns):
                predicate = g.Is (g.Index (binding, g.lift (1)), g.lift (pat_id))
                if started:
                    gen.ElIf (predicate)
                else:
                    gen.If (predicate)
                    started = True
                if len (variables[pattern]) > 0:
                    gen.Assign (g.Tuple (*map (g.Id, variables[pattern])),
                                g.Slice (binding, g.lift (2), None))
                else:
                    gen.line (g.Id ('pass'))
                gen.dedent ()
            gen.inline (body)
        
        return gen.target

class PatternCompiler (object):
    """Generates the code needed to check if an object matches a pattern"""
    
    def __init__ (self, binding, target=None):
        self.gen = g.CodeGenerator (target)
        self.binding = binding
    
    def compile (self, pattern, predicate):
        self.bindings = dict ()
        
        initialIndent = self.gen.indent
        self.__compile_pattern (pattern, self.binding)
        if predicate:
            if len (self.bindings) > 0:
                variables, bindings = zip (*self.bindings.items ())
                self.gen.Assign (g.Tuple (*map (g.Id, variables)), g.Tuple (*bindings))
            self.gen.If (predicate)
        
        return self.gen.indent - initialIndent
    
    def __compile_pattern (self, pattern, binding):
        if isinstance (pattern, PLit):
            self.gen.If (g.Eq (binding, g.Token (pattern.token)))
        elif isinstance (pattern, PSym):
            self.gen.If (g.Eq (binding, g.Id (pattern.name)))
        elif isinstance (pattern, PVar):
            self.__bind (pattern.name, binding)
        elif isinstance (pattern, PTuple):
            self.__emit_type_check ('__builtins__.tuple', binding)
            self.__compile_listlike (pattern.patterns, binding)
        elif isinstance (pattern, PList):
            self.__emit_type_check ('__builtins__.list', binding)
            self.__compile_listlike (pattern.patterns, binding)
        elif isinstance (pattern, PDict):
            self.__emit_type_check ('__builtins__.dict', binding)
            for pairing in pattern.pairings:
                if isinstance (pairing, PSplat):
                    self.__bind (pairing.name, binding)
                else:
                    self.gen.If (g.In (g.Token (pairing[0].token), binding))
                    self.__compile_pattern (pairing[1], g.Index (binding, g.Token (pairing[0].token)))
        elif isinstance (pattern, PExtractor):
            extractedBinding = g.Id (g.UniqueName ())
            self.gen.Assign (extractedBinding,
                             g.Call (g.Method (g.Id (pattern.extractor), '__match__'), binding))
            self.gen.If ( g.IsNot (extractedBinding, g.lift (None)))
            self.__compile_listlike (pattern.patterns, extractedBinding)
        elif isinstance (pattern, PBind):
            self.__bind (pattern.name, binding)
            self.__compile_pattern (pattern.pattern, binding)
        else:
            raise TypeError, 'expected pattern (got %s)' % type(pattern)
    
    def __bind (self, name, binding):
        if name != '_':
            if name in self.bindings:
                self.gen.If (g.Eq (self.bindings[pattern.name], binding))
            else:
                self.bindings[name] = binding
    
    def __emit_type_check (self, typename, binding):
        self.gen.If (g.Call (g.Id ('__builtins__.isinstance'), binding, g.Id(typename)))
    
    def __compile_listlike (self, patterns, binding):
        splatIndex = None
        for index in range (len (patterns)):
            if isinstance (patterns[index], PSplat):
                splatIndex = index
                break
        if splatIndex is None:
            self.gen.If (g.Eq (g.Call (g.Id ('__builtins__.len'), binding), g.lift (len (patterns))))
            for index in range (len (patterns)):
                self.__compile_pattern (patterns[index], g.Index (binding, g.lift (index)))
        else:
            self.gen.If (g.Gt (g.Call (g.Id ('__builtins__.len'), binding), g.lift (len (patterns) - 2)))
            sliceEnd = -(len (patterns) - splatIndex - 1)
            if sliceEnd == 0:
                sliceEnd = None
            else:
                g.lift (sliceEnd)
            self.__bind (patterns[splatIndex].name, g.Slice (binding, g.lift (splatIndex),  sliceEnd))
            for index in range (len (patterns)):
                if index == splatIndex: continue
                elif index > splatIndex:
                    index = len (patterns) - index
                self.__compile_pattern (patterns[index], g.Index (binding, g.lift (index)))
    

if __name__ == '__main__':
    import sys
    sys.exit(main(sys.argv))
